<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>编程小记</title>
  <icon>https://www.gravatar.com/avatar/208c3e903a28ee32a6bd45585b847e2b</icon>
  <subtitle>记录所看所学，不断沉淀</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.zhanghuiliang.cn/"/>
  <updated>2019-05-05T14:21:23.451Z</updated>
  <id>http://blog.zhanghuiliang.cn/</id>
  
  <author>
    <name>CrazyHuiLiang</name>
    <email>crazyhuiliang@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js对象创建</title>
    <link href="http://blog.zhanghuiliang.cn/2019/05/05/js%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/"/>
    <id>http://blog.zhanghuiliang.cn/2019/05/05/js对象创建/</id>
    <published>2019-05-05T14:21:23.000Z</published>
    <updated>2019-05-05T14:21:23.451Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>创建一个对象最简单的方法莫过于使用字面量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var animalA = &#123;</span><br><span class="line">name: &apos;animal&apos;,</span><br><span class="line">age: 1,</span><br><span class="line">relations: [],</span><br><span class="line">run: function () &#123;</span><br><span class="line">console.log(&apos;run&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里我们创建了一个animalA对象，他具有三个属性，一个方法。这种创建对象的方法因为简单，所以也是较为常用的一种方法，不过一次只能创建出一个对象，也就是这里的animalA，如果要再次创建一个同样结构的animalB就需要重复写一遍后面的字面量，创建过程不能重用。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式是使用一个函数来封装对象的创建过程，每次创建对象是就通过对工厂方法的调用来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function createAnimal(name, age) &#123;</span><br><span class="line">var animal = &#123;&#125;;</span><br><span class="line">animal.name = name;</span><br><span class="line">animal.age = age;</span><br><span class="line">animal.relations = [];</span><br><span class="line">animal.run = function () &#123;</span><br><span class="line">console.log(&apos;run&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">return animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var animalA = createAnimal(&apos;animalA&apos;, 1);</span><br><span class="line">var animalB = createAnimal(&apos;animalB&apos;, 2);</span><br><span class="line"></span><br><span class="line">console.log(animalA.constructor, animalB.constructor); // Object() &#123;&#125;, Object() &#123;&#125;</span><br></pre></td></tr></table></figure><p>这里我们定义了一个createAnimal函数，每次调用即可返回一个具有3个属性，一个方法的对象。工厂模式规避了字面量方式创建相似对象时比较繁琐的问题，但是他没有产生对象类型标示，通过打印animalA和animalB的constructor可以发现输出的都是Object。</p><h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><p>在js中，可以通过函数名前添加new操作符来创建对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Animal (name, age) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">this.relations = [];</span><br><span class="line">this.run = function () &#123;</span><br><span class="line">console.log(&apos;run&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var animalA = new Animal(&apos;animalA&apos;, 1);</span><br><span class="line">var animalB = new Animal(&apos;animalB&apos;, 2);</span><br><span class="line"></span><br><span class="line">console.log(animalA.constructor); // Animal() &#123;&#125;</span><br><span class="line">console.log(animalA.run === animalB.run); // false</span><br></pre></td></tr></table></figure><p>使用new操作符调用函数时，运行环境会创建一个新对象，然后将构造函数的作用域赋给新对象（this也就指向这个新对象），运行函数，在函数运行结束后如果没有显式的return值，就会将创建的这个新对象作为返回值返回。</p><p>使用构造函数可以重用创建过程，创建的对象具有相同的类型标识（constructor），不过我们对比初始化出的两个实例的run方法会发现它们并不相等，也就是说每次每个实例对象都独立拥有一个自己的run方法，这显然是不够经济且不符合我们对它们的一致性的期望。</p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>js函数具有一个prototype属性，使用函数名前加new操作符创建的实例内部会有一个[[prototype]]指针指向构造函数的prototype属性,访问实例的属性时会先对实例自身进行查找，如果查找不到会继续查找实例的[[prototype]]，查找仍然失败就继续查找[[prototype]]的[[prototype]]，依此规则持续进行直到查找成功或失败。所以，将属性放在函数的prototype属性上可以实现实例之间共享数据的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Animal() &#123;&#125;</span><br><span class="line">Animal.prototype.name = &apos;&apos;;</span><br><span class="line">Animal.prototype.age = 0;</span><br><span class="line">Animal.prototype.relations = [];</span><br><span class="line">Animal.prototype.run = function() &#123;</span><br><span class="line">console.log(&quot;run&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var animalA = new Animal();</span><br><span class="line">var animalB = new Animal();</span><br><span class="line"></span><br><span class="line">console.log(animalA instanceof Animal); // true</span><br><span class="line">console.log(animalA.run === animalB.run); // true</span><br><span class="line">console.log(animalA.relations); // []</span><br><span class="line">animalB.relations.push(&apos;fish&apos;);</span><br><span class="line">console.log(animalA.relations); // [&apos;fish&apos;]</span><br></pre></td></tr></table></figure><p>使用原型模式由于所创建的实例的[[prototype]]都指向的是Animal.prototype，所以可以看到他避免了构造函数模式两次创建的实例的run函数不相等的问题，但是原型上的其他引用类型的属性也被共用，因此导致了一个实例更改了原型中引用类型的数据，其他实例访问数据也会变化。</p><h2 id="组合构造函数和原型模式"><a href="#组合构造函数和原型模式" class="headerlink" title="组合构造函数和原型模式"></a>组合构造函数和原型模式</h2><p>仅使用构造函数实例间不能重用函数，仅使用原型模式重用的函数的同时也会导致引用类型的值的重用，因此不难想象我们可以组合使用两者。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Animal(name, age) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">this.relations = [];</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.run = function () &#123;</span><br><span class="line">console.log(&apos;run&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var animalA = new Animal(&apos;dog&apos;, 1);</span><br><span class="line">var animalB = new Animal(&apos;cat&apos;, 1);</span><br><span class="line"></span><br><span class="line">console.log(animalA.run === animalB.run);// true</span><br><span class="line">console.log(animalA.relations); // []</span><br><span class="line">animalB.relations.push(&apos;fish&apos;);</span><br><span class="line">console.log(animalA.relations); // []</span><br></pre></td></tr></table></figure><p></p><p>组合使用了构造函数模式和原型模式后，解决了对象类型标示问题，可以重用constructor和其他函数,这是一个典型的对象创建的范例。</p><h2 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h2><p>构造函数模式和原型模式组合使用后确实是一种不错的实践方式，不过在为构造函数的原型添加函数的代码在构造函数之外，这自然是给人一种封装不足的感觉，我们可以通过在构造函数内部,对函数原型是否已经赋值的判断来动态的添加原型方法,从而实现进一步的封装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Animal(name, age) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">this.relations = [];</span><br><span class="line">if (!Animal.prototype.run) &#123;</span><br><span class="line">Animal.prototype.run = function () &#123;</span><br><span class="line">console.log(&apos;run&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var animalA = new Animal(&apos;dog&apos;, 1);</span><br><span class="line">var animalB = new Animal(&apos;cat&apos;, 1);</span><br><span class="line"></span><br><span class="line">console.log(animalA.constructor); // Animal() &#123;&#125;</span><br><span class="line">console.log(animalA.run === animalB.run);// true</span><br><span class="line">console.log(animalA.relations); // []</span><br><span class="line">animalB.relations.push(&apos;fish&apos;);</span><br><span class="line">console.log(animalA.relations); // []</span><br></pre></td></tr></table></figure><p>通过代码可以看到，我们将在原型上添加函数的代码移至函数内部，通过最初的一次判断来确定为原型添加函数的逻辑只会在构造函数第一次被调用时执行。动态原型模式可以理解为是组合构造函数和原型模式的另一种写法。</p><h2 id="寄生构造函数"><a href="#寄生构造函数" class="headerlink" title="寄生构造函数"></a>寄生构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Animal(name, age) &#123;</span><br><span class="line">var animal = &#123;&#125;;</span><br><span class="line">animal.name = name;</span><br><span class="line">animal.age = age;</span><br><span class="line">animal.relations = [];</span><br><span class="line">animal.run = function () &#123;</span><br><span class="line">console.log(&apos;run&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">return animal;</span><br><span class="line">&#125;</span><br><span class="line">var animalA = new Animal(&apos;dog&apos;, 1);</span><br><span class="line">var animalB = new Animal(&apos;cat&apos;, 1);</span><br><span class="line"></span><br><span class="line">console.log(animalA.constructor); // Object() &#123;&#125;</span><br><span class="line">console.log(animalA instanceof Animal); // false</span><br></pre></td></tr></table></figure><p>寄生构造函数除了使用new操作符调用和把函数叫做构造函数外，看起来跟工厂模式没有任何区别。寄生构造函数模式创建的实例与构造函数的原型属性之间没有关系，所以实例的constructor并不指向构造函数，也无法使用instanceof来判断实例的类型。正常情况下不推荐使用，除非你要为已有类型扩展功能（装潢模式）,比如:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function SpecialArray() &#123;</span><br><span class="line">var array = new Array();</span><br><span class="line">array.push.apply(array, arguments);</span><br><span class="line">array.toPipedString = function () &#123;</span><br><span class="line">return this.join(&quot;|&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">return array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var colors = new SpecialArray(&apos;red&apos;, &apos;blue&apos;, &apos;grey&apos;);</span><br><span class="line">console.log(colors.toPipedString()); // red|blue|grey</span><br></pre></td></tr></table></figure><p></p><h2 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h2><p>Douglas Crockford发明了JavaScript中的稳妥对象的概念，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象适用于一些安全的环境中（禁止使用new和this），稳妥构造函数和寄生构造函数类似，但有亮点不同，一是新创建对象的实例方法中不使用this，二是不使用new操作符调用构造函数。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Animal(name, age) &#123;</span><br><span class="line">var animal = &#123;&#125;;</span><br><span class="line">animal.run = function () &#123;</span><br><span class="line">console.log(name + &apos; run&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">return animal;</span><br><span class="line">&#125;</span><br><span class="line">var animalA = new Animal(&apos;dog&apos;, 1);</span><br><span class="line">animalA.run();</span><br></pre></td></tr></table></figure><p></p><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>ES6中新添加了class关键字，可以通过class来定义类，通过对类进行实例化来创建对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">constructor(name, age) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run() &#123;</span><br><span class="line">console.log(&apos;run&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static hello() &#123;</span><br><span class="line">console.log(&apos;hello&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(typeof Animal); // function</span><br><span class="line">var animalA = new Animal(&apos;dog&apos;, 1);</span><br><span class="line">console.log(typeof animalA); // object</span><br><span class="line">console.log(animalA.constructor); // class Animal1&#123;&#125;</span><br><span class="line">console.log(animalA instanceof Animal); // true</span><br></pre></td></tr></table></figure><p>使用class关键字后面跟类名，跟大括号，在大括号中名为constructor的函数就是构造函数，实例属性可以在constructor中进行初始化，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;字面量&quot;&gt;&lt;a href=&quot;#字面量&quot; class=&quot;headerlink&quot; title=&quot;字面量&quot;&gt;&lt;/a&gt;字面量&lt;/h2&gt;&lt;p&gt;创建一个对象最简单的方法莫过于使用字面量：&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo使用</title>
    <link href="http://blog.zhanghuiliang.cn/2019/04/25/hexo%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.zhanghuiliang.cn/2019/04/25/hexo使用/</id>
    <published>2019-04-25T12:54:14.000Z</published>
    <updated>2019-04-26T08:25:28.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>在说hexo之前要先说一下写博客过程，我们要写一篇博客时通常采用Markdown格式的文件，简单来说，Markdown就是通过简单的对文本进行标记来实现一些页面布局效果的一种方案。一篇Markdown格式的文章写完后，再把Markdown格式转化成html格式的文件用来网站部署，到这里就可以说一下hexo了。</p><p>hexo是一款基于nodejs平台的博客类网站生成工具，使用hexo可以帮我们方便组织我们的Markdown文件、可以帮我们把Markdown格式的文章生成静态html页面、通过插件还可以帮我们把生成的html页面部署到生产环境。</p><p>下面我们就来说一下hexo从安装,到写作,到部署至<a href="https://pages.github.com" target="_blank" rel="noopener">GitHub Pages</a>的过程,由于本文主要是对hexo的简单描述，所以本文章默认你已经安装了nodejs，并且对github有所了解（新建仓库），这里对这些概念不再展开描述了。</p><h2 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h2><p>使用hexo之前要先全局安装hexo的命令行工具：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装完成hexo之后系统就会有一个hexo的命令行工具可以使用，可以使用下面三行命令来创建hexo’工程’;<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;   # 创建hexo工程,把&lt;folder&gt;替换成你想要的名字</span><br><span class="line"></span><br><span class="line">$ cd &lt;folder&gt;          # 进入工程目录</span><br><span class="line"></span><br><span class="line">$ npm install       # 安装项目依赖</span><br></pre></td></tr></table></figure><p></p><p>为了后面的叙述方便，我们需要的一些hexo的插件在这里也一气呵成都安装上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-all-minifier  # 一个可以把生成的网页文件进行压缩，有利于提升网站的访问速度</span><br><span class="line"></span><br><span class="line">$ npm install hexo-deployer-git  # 一个可以帮助我们部署网站的插件</span><br></pre></td></tr></table></figure><h2 id="hexo-项目目录结构"><a href="#hexo-项目目录结构" class="headerlink" title="hexo 项目目录结构"></a>hexo 项目目录结构</h2><p>到目前为止，我们的hexo工程已经创建完毕，下面对hexo项目的重要的几个目录以及文件做一下介绍：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_config.yml     # 项目的配置文件</span><br><span class="line">public          # 生成的网站文件，稍后部署博客网站也就是部署这个目录中的文件</span><br><span class="line">scaffolds       # 文章模版，创建新文章时可以选择的模版</span><br><span class="line">source          # 存放我们写的文章（Markdown）</span><br><span class="line">  _discarded        # 存放丢弃的文章，理解成垃圾娄把</span><br><span class="line">  _drafts           # 存放草稿，还没有完全写完的文章可以先放在这个目录下</span><br><span class="line">  _posts            # 存放我们要发布的文章，放在这个目录下的Markdown文件稍后都会生成对应的网页</span><br></pre></td></tr></table></figure><h2 id="常用的hexo命令"><a href="#常用的hexo命令" class="headerlink" title="常用的hexo命令"></a>常用的hexo命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;filename&gt;     # 新建一篇文章,layout指scaffolds目录中的模版文件，默认已经有draft、page、post可以选择，如果有需要的话你还可以继续新建模版;新建的文章会放在source/_posts 目录下，有一个例外就是layout设置为draft时文件会放在source/_drafts目录下。</span><br><span class="line"></span><br><span class="line">$ hexo publish [layout] &lt;filename&gt; # 发布草稿，会把source/_drafts目录下的文件转移到source/_posts目录下。</span><br><span class="line"></span><br><span class="line">$ hexo server                      # 开启一个可以预览生成的blog效果的服务。</span><br><span class="line"></span><br><span class="line">$ hexo generate                    # 生成网站，会生成source/_posts目录下文章对应的网页文件，网页文件放在public目录下。</span><br><span class="line"></span><br><span class="line">$ hexo deploy                      # 部署网站,部署方法下面会说</span><br></pre></td></tr></table></figure><h2 id="部署准备"><a href="#部署准备" class="headerlink" title="部署准备"></a>部署准备</h2><p>部署网站可以按照自己的喜好部署，在这里给出一种依赖github pages来进行部署的方案，github pages给提供了网站部署功能，使用方法是在github中创建以 ‘用户名.github.io’为名称的一个仓库，然后在这个仓库上传的文件可以通过’用户名.github.io’域名进行访问。创建步骤如下：</p><ol><li>登录 <a href="https://github.com/" target="_blank" rel="noopener">github</a>,如果没有账号的话就注册一个</li><li>创建一个git仓库，名称必须是‘&lt;你的github名称&gt;.github.io’</li><li>在仓库页面，点击’clone and downlowd’复制仓库地址，留作稍后部署之用（仓库链接是以.git结尾的那个链接，不是页面浏览器地址框中的链接哈）</li></ol><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>_config.yml是hexo的配置文件,详细的字段解释在这里也不再赘述，可以看官网的<a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">文档</a>，需要说一下的是关于部署的配置和我们对页面压缩插件的配置，打开_config.yml文件。</p><p>找到deploy选项：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">把deploy下的type配置为git</span><br><span class="line"></span><br><span class="line">repo 配置为刚才复制的github仓库地址</span><br><span class="line"></span><br><span class="line">配置好后大致长这样：</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: https://github.com/xxxx/xxxx.github.io.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure><p></p><p>在页面最底下添加：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_minifier: true # hexo-all-minifier 插件的配置</span><br></pre></td></tr></table></figure><p></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>截止目前为止，我们已经创建并设置好了hexo项目，使用以下两行命令即可完成部署:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate # 生成网站文件</span><br><span class="line">hexo deploy   # 部署网站,第一次会让输入github名称和密码</span><br></pre></td></tr></table></figure><p></p><p>部署成功后可以在浏览器中输入 ‘你的github名称.github.io’进行查看部署效果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>初接触hexo时，需要先进行hexo的安装，和配置，这些都搞定后以后使用中最常做的操作也就是通过<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &lt;filename&gt;</span><br></pre></td></tr></table></figure><p></p><p>创建文章，然后编辑source/_post目录下的文章，最后执行<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p></p><p>生成网站，并部署：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;p&gt;在说hexo之前要先说一下写博客过程，我们要写一篇博客时通常采用Markdown格式的文件，简单来说，Markdown就是通过简单的对文本进
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://blog.zhanghuiliang.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Macports使用简介</title>
    <link href="http://blog.zhanghuiliang.cn/2017/09/08/Macports/"/>
    <id>http://blog.zhanghuiliang.cn/2017/09/08/Macports/</id>
    <published>2017-09-08T02:34:10.000Z</published>
    <updated>2017-09-14T06:23:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://www.macports.org/" target="_blank" rel="noopener">Macports</a>是一款供Mac系统的包管理器，主要用来安装软件，卸载软件更新软件等。继续阅读之前需要按照<a href="https://www.macports.org/install.php" target="_blank" rel="noopener">官网</a>指示安装Macports.</p><p>如果使用官网提供的安装器安装，安装成功后，默认会将Macports拷贝到 <em>/opt/local</em>,执行文件将放在<em>/opt/local/bin</em>,其他文件会放在<em>/opt/local/var/macports</em>,最后会把目录<em>/opt/local</em>通过配置文件<em>~/.profile</em>添加到环境变量中(PATH)中。</p><p>可以通过:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ port version</span><br></pre></td></tr></table></figure><p></p><p>port是Macports的执行命令,上面的命令可以查看Macports的版本，如果成功输出如<em>Version: 2.4.1</em>滋字样，说明Macports已经安装成功了，否则就需要检查是否安装失败，或者环境变量添加失败。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><strong>1. 查看帮助</strong><br>可以通过linux man命令查看:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ man port</span><br><span class="line">$ man macports.conf</span><br></pre></td></tr></table></figure><p></p><p>Macports也提供了port help命令查看帮助文档:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查看port的帮助文档</span><br><span class="line">$ port help </span><br><span class="line"></span><br><span class="line">其后跟行为参数，可以查看行为的详细介绍，如：</span><br><span class="line">$ port help selfupdate</span><br></pre></td></tr></table></figure><p></p><p><strong>2. port selfupdate</strong><br>port命令后跟selfupdate指令可以更新Macports、本地Portfiles（保存服务器port信息的数据库）(因此安装成功后就应该检查更新一次)。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo port selfupdate</span><br></pre></td></tr></table></figure><p></p><p>selfupdate后可跟参数：</p><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>-d</td><td>开启debug模式，一旦命令执行错误，可以查看更多详细信息</td></tr><tr><td>–nosync</td><td>只更新Macports本身，不更新本地数据库</td></tr></tbody></table><p><strong>3. port diagnose</strong><br>检查运行环境常见问题，把发现的问题都列出来<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ port diagnose</span><br></pre></td></tr></table></figure><p></p><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>–quiet</td><td>只显示警告和错误，不显示执行脚本状态</td></tr></tbody></table><p><strong>4. port reclaim</strong><br>移除不活跃的软件<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ port reclaim</span><br></pre></td></tr></table></figure><p></p><p><strong>5. port list</strong><br>列出所有可以通过Macports安装的port的列表（不是已安装的列表）。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ port list</span><br></pre></td></tr></table></figure><p></p><p><strong>6. port search</strong></p><p>匹配名称／描述符合关键词的软件，如搜索php：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ port search php</span><br></pre></td></tr></table></figure><p></p><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>–glob</td><td>对给定的搜索字符串作为全局搜索的字符串（即扩展通配符*、？和[字符]。这是默认行为。</td></tr><tr><td>–regex</td><td>将给定搜索字符串视为正则表达式。</td></tr><tr><td>—line</td><td>指定每一个匹配的port信息在一行上输出</td></tr><tr><td>–case-sensitive</td><td>大小写敏感</td></tr><tr><td>field</td><td>测试搜索关键字与指定字段（field）进行匹配，默认匹配字段为 —name —description</td></tr></tbody></table><p>可用的field字段有：</p><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>–category, –categories</td><td>在指定分类中搜索</td></tr><tr><td>–depends, –depends_build, –depends_extract, –depends_fetch, –depends_lib, –depends_run</td><td>搜索所有依赖名为搜索关键字的port的port，–depends包含其他所有的–depends_ options。</td></tr><tr><td>–description, –long_description</td><td>对port的描述部分进行匹配</td></tr><tr><td>—homepage</td><td>对所有ports的homepage字段进行匹配</td></tr><tr><td>–maintainer, –maintainers</td><td>搜索某个维护者相关的ports</td></tr><tr><td>—name</td><td>只对port的名称进行匹配</td></tr><tr><td>–portdir</td><td>匹配包含在给定目录名下的port</td></tr><tr><td>–variant, –variants</td><td>搜索匹配关键字的变体</td></tr></tbody></table><p><strong>7. port info</strong><br>可以获取软件的信息，如（名称，版本，官网等），如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ port info nginx</span><br></pre></td></tr></table></figure><p></p><p><strong>8. port deps</strong><br>可以查询软件的依赖</p><p><strong>9. port variants</strong><br>port variants 查询新版本相对于已安装版本的差异</p><p><strong>10. port install</strong><br>安装软件，例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo port install apache2 -preforkmpm +workermpm</span><br></pre></td></tr></table></figure><p></p><p>安装apache2，不安装其中的preforkmpm，安装workermpm.<br>如果安装失败可以通过port logfile<portname>查看日志，sudo port clean<portname>清除安装失败的port。</portname></portname></p><p><strong>11. port clean</strong><br>清理安装过程中所产生的文件，在安装软件失败后经常会用到<br>sudo port clean<portname><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo port clean mysql56</span><br></pre></td></tr></table></figure></portname></p><p>参数：</p><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>–archive</td><td>清理临时压缩文件</td></tr><tr><td>–dist</td><td>清理下载的文件</td></tr><tr><td>–logs</td><td>清理日志文件</td></tr><tr><td>–work</td><td>清理安装进程所用目录，此目录是MacPorts构建软件所用，此选项是默认选项。</td></tr><tr><td>–all</td><td>清理所有</td></tr></tbody></table><p><strong>12. port uninstall</strong><br>卸载安装</p><p>格式:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo port uninstall &lt;portname&gt;</span><br></pre></td></tr></table></figure><p></p><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>–follow-dependents</td><td>Macports不会卸载还被依赖的port，此选项可以递归卸载安装，比如B 依赖A，卸载A默认是不可以的，使用此选项可以先卸载B，再卸载A。</td></tr><tr><td>–follow-dependencies</td><td>Macports不会卸载安装port时所安装的依赖，此选项可以卸载那些被卸载软件的依赖但并没有被其他软件所依赖的软件。</td></tr><tr><td>-f</td><td>(force)，强制卸载port，忽略软件间的依赖关系（尽量不要使用这个选项，除非你特别清楚你所做的操作）</td></tr><tr><td>–no-exec</td><td>卸载时不在触发事件监听，比如卸载时更新本地缓存将不会被执行。</td></tr></tbody></table><p><strong>13. port contents</strong><br>列出所有指定软件的所有安装的文件,此命令经常被用来寻找所安装软件的执行文件路径：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ port  contents &lt;portname&gt; | grep -E &apos;/s?bin/&apos;</span><br></pre></td></tr></table></figure><p></p><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>–size</td><td>列出文件时，同时给出文件大小</td></tr><tr><td>— units ‘UNIT’</td><td>配合—size使用，指定显示文件大小的单位</td></tr></tbody></table><p>‘UNIT’包含以下几种：<br>B<br>K, Ki,KiB<br>Mi,MiB<br>Gi,GiB<br>k, kB<br>M, MB<br>G, GB</p><p><strong>14. port installed</strong><br>列出已安装的软件及其变体，可以指定软件名，显示与所指定软件相关的安装。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ port installed</span><br></pre></td></tr></table></figure><p></p><p>-v 显示安装的平台以及CPU等信息</p><p><strong>15. port outdated</strong><br>列出所有版本已旧（已有新版本发布）的软件。</p><p><strong>16. port upgrade</strong><br>更新旧版本的已安装软件及其依赖，如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ port upgrade nginx</span><br><span class="line">更新nginx</span><br><span class="line"></span><br><span class="line">$ port upgrade outdated</span><br><span class="line">更新所有旧版本已安装软件及其依赖，</span><br></pre></td></tr></table></figure><p></p><p><strong>17. port dependents</strong><br>查询依赖已安装的指定软件的软件,比如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ port dependents php56</span><br><span class="line">查询电脑中有哪些软件依赖php56</span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.macports.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mac
      
    
    </summary>
    
    
      <category term="Mac" scheme="http://blog.zhanghuiliang.cn/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>CentOS虚拟机无法连接网络</title>
    <link href="http://blog.zhanghuiliang.cn/2016/12/16/CentOS%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BB%9C/"/>
    <id>http://blog.zhanghuiliang.cn/2016/12/16/CentOS虚拟机无法连接网络/</id>
    <published>2016-12-16T07:54:51.000Z</published>
    <updated>2017-09-08T02:34:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>cd /etc/sysconfig/network-scripts/</p><p>sudo vim ifcfg-eno16777736</p><p>更改ONBOOT=no 为 ONBOOT=yes</p><p>重启网络 service network restart</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;cd /etc/sysconfig/network-scripts/&lt;/p&gt;&lt;p&gt;sudo vim ifcfg-eno16777736&lt;/p&gt;&lt;p&gt;更改ONBOOT=no 为 ONBOOT=yes&lt;/p&gt;&lt;p&gt;重启网络 service network restart&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog.zhanghuiliang.cn/tags/Linux/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>编程小记</title>
  <icon>https://www.gravatar.com/avatar/208c3e903a28ee32a6bd45585b847e2b</icon>
  <subtitle>记录所看所学，不断沉淀</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.zhanghuiliang.cn/"/>
  <updated>2019-05-12T14:01:40.600Z</updated>
  <id>http://blog.zhanghuiliang.cn/</id>
  
  <author>
    <name>CrazyHuiLiang</name>
    <email>crazyhuiliang@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js正则</title>
    <link href="http://blog.zhanghuiliang.cn/2019/05/12/js%E6%AD%A3%E5%88%99/"/>
    <id>http://blog.zhanghuiliang.cn/2019/05/12/js正则/</id>
    <published>2019-05-12T10:22:47.000Z</published>
    <updated>2019-05-12T14:01:40.600Z</updated>
    
    <content type="html"><![CDATA[<p>字符串操作在我们编程中是经常会接触到的，正则表达式是一把操作字符串的利器，我们今天就来罗列一下js正则相关的api。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>js中提供了字面量和调用RegExp构造函数两种方式来创建正则表达式实例。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 字面量写法</span><br><span class="line">var expression = / pattern / flags;</span><br></pre></td></tr></table></figure><p></p><p>pattern可以是任何正则表达式(包含字符类、限定符、分组、向前查找、反向引用),模式中使用的所有元字符都必须转义。正则表达式中的元字符包括 ( [ { \ ^ $ | ) ? * + . ] }。flags可取以下几种：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g: 表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止</span><br><span class="line">i: 表示不区分大小写（case-insensitive)模式，即在确定匹配项时忽略模式与字符串的大小写</span><br><span class="line">m: 表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项</span><br><span class="line">u: 支持Unicode扩展字符集的匹配（ES6新增）</span><br><span class="line">y: 影响搜索过程的sticky属性,后面会具体介绍（ES6新增）</span><br></pre></td></tr></table></figure><p></p><p>使用构造函数时,第一个参数是字符串类型时，相对于字面量写法，如果有需要转义的字符串，相对于字面量写法需要再多一次转义;如果是一个正则表达式时，会对传入的正则表达式进行复制，在ES6之前，不允许传入第二个参数，否则会发生语法错误，在ES6之后，传入的第二个参数会覆盖原正则表达式的标识符。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 使用构造函数</span><br><span class="line">var expression = new RegExp(pattern, flags)</span><br></pre></td></tr></table></figure><p></p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>正则表达式具有一些实例属性，我们可以使用下面的表达式依次尝试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 匹配第一个&apos;bat&apos;或&apos;cat&apos;,不区分大小写</span><br><span class="line">var pattern2 = /[bt]at/i;</span><br><span class="line"></span><br><span class="line">以下属性都使用此表达式</span><br></pre></td></tr></table></figure><h3 id="global"><a href="#global" class="headerlink" title="global"></a>global</h3><p>可以用来判断正则表达式是否具有g标识<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;global\t\t&apos;, pattern2.global); // global false</span><br></pre></td></tr></table></figure><p></p><h3 id="ignoreCase"><a href="#ignoreCase" class="headerlink" title="ignoreCase"></a>ignoreCase</h3><p>用于判断正则表达式是否具有i标识<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;ignoreCase\t&apos;, pattern2.ignoreCase); // ignoreCase true</span><br></pre></td></tr></table></figure><p></p><h3 id="lastIndex"><a href="#lastIndex" class="headerlink" title="lastIndex"></a>lastIndex</h3><p>用来确定下一次正则匹配的起始位置<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;lastIndex\t&apos;, pattern2.lastIndex); // lastIndex 0</span><br></pre></td></tr></table></figure><p></p><h3 id="multiline"><a href="#multiline" class="headerlink" title="multiline"></a>multiline</h3><p>用于判断正则表达式是否具有m标识<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;multiline\t&apos;, pattern2.multiline); // multiline false</span><br></pre></td></tr></table></figure><p></p><h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>返回正则表达式的字面量字符, 在ES6之前会返回包括表达式标识完整的字面量，ES6之后，只返回表达式本身，不包含标识（为获取标识提供了单独的flags属性）。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;source\t\t&apos;, pattern2.source); // source [bt]at</span><br></pre></td></tr></table></figure><p></p><h3 id="unicode"><a href="#unicode" class="headerlink" title="unicode"></a>unicode</h3><p>属性用来判断正则表达式有没有u标识符 (ES6新增)<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;unicode&apos;, pattern2.unicode); // unicode false</span><br></pre></td></tr></table></figure><p></p><h3 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h3><p>属性来判断表达式是否有y标识<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;sticky&apos;, pattern2.sticky); // sticky false</span><br></pre></td></tr></table></figure><p></p><h3 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h3><p>用于查看正则表达式的所有标识, （ES6新增）<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;flags&apos;, pattern2.flags); // flags i</span><br></pre></td></tr></table></figure><p></p><h2 id="正则表达式函数"><a href="#正则表达式函数" class="headerlink" title="正则表达式函数"></a>正则表达式函数</h2><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>正则表达式exec函数执行后，如果字符串不匹配正则表达式，会返回null，可以匹配的话，会返回一个数组对象，数组的第一项为匹配的字符串，其后为捕获组所捕获的字符串，如果表达式中不含捕获组，数组就只有一项数据，该数组对象相对于普通数组会拥有额外的两个属性index和input，index是字符串中匹配字串首字符的下标，input即被校验的字符串。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var text = &apos;mom and dad and baby&apos;;</span><br><span class="line">var pattern = /mom( and dad( and baby)?)?/gi;</span><br><span class="line">var matches = pattern.exec(text);</span><br><span class="line">if (matches) &#123;</span><br><span class="line">console.log(matches.index); // 0</span><br><span class="line">console.log(matches.input); // mom and dad and baby</span><br><span class="line">console.log(matches[0]); // mom and dad and baby</span><br><span class="line">console.log(matches[1]); //  and dad and baby</span><br><span class="line">console.log(matches[2]); //  and baby</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>正则中不使用g标志时，每次调用exec函数都会返回第一个匹配项的信息,表达式的lastIndex属性每次都返回0<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var text = &apos;cat, bat, sat, fat&apos;;</span><br><span class="line">var pattern = /.at/;</span><br><span class="line"></span><br><span class="line">var matches = pattern.exec(text);</span><br><span class="line">console.log(matches.index, matches[0], pattern.lastIndex); // 0 &apos;cat&apos; 0</span><br><span class="line"></span><br><span class="line">var matches = pattern.exec(text);</span><br><span class="line">console.log(matches.index, matches[0], pattern.lastIndex); // 0 &apos;cat&apos; 0</span><br></pre></td></tr></table></figure><p></p><p>正则中使用g标志时，每次调用exec后都会返回新的匹配项，直到没有匹配项,表达式的lastIndex属性每次都调用过exec都会增加，变为上次匹配字符的后一字符的下标<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var pattern = /.at/g;</span><br><span class="line"></span><br><span class="line">var matches = pattern.exec(text);</span><br><span class="line">console.log(matches.index, matches[0], pattern.lastIndex); // 0 &apos;cat&apos; 3</span><br><span class="line">var matches = pattern.exec(text);</span><br><span class="line">console.log(matches.index, matches[0], pattern.lastIndex); // 5 &apos;bat&apos; 8</span><br><span class="line">var matches = pattern.exec(text);</span><br><span class="line">console.log(matches.index, matches[0], pattern.lastIndex); // 10 &apos;sat&apos; 13</span><br><span class="line">var matches = pattern.exec(text);</span><br><span class="line">console.log(matches.index, matches[0], pattern.lastIndex); // 15 &apos;fat&apos; 18</span><br></pre></td></tr></table></figure><p></p><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>正则表达式中的test方法接收一个字符串参数，当前模式与参数匹配的话返回true，否则返回false，test方法经常用于只想要检测字符是否符合规则，不关心字符内容的场景，常用于对用户输入进行校验。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var text = &apos;000-00-0000&apos;;</span><br><span class="line">var pattern = /\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/;</span><br><span class="line">console.log(pattern.test(text)); // true</span><br></pre></td></tr></table></figure><p>值得注意的是，表达式中有g标识时，同exec函数一样，每次执行会从上次匹配结尾处向后继续尝试匹配，完成最后一次匹配后的下一次调用将会返回false，再下一次调用会重新从字符串开始处进行模式匹配。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var text = &apos;bad dad eazy go mad.&apos;;</span><br><span class="line">var pattern = /.ad/g;</span><br><span class="line">console.log(pattern.test(text)); // true</span><br><span class="line">console.log(pattern.test(text)); // true</span><br><span class="line">console.log(pattern.test(text)); // true</span><br><span class="line">console.log(pattern.test(text)); // false</span><br></pre></td></tr></table></figure><p></p><h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><p>RegExp构造函数包含一些属性，这些属性适用于作用域中的所有正则表达式，并且基于所执行的最后一次正则表达式操作而变化。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var text = &apos;this is a wonderful year!&apos;;</span><br><span class="line">var pattern = /(...)der(...)/gi;</span><br><span class="line">if (pattern.test(text)) &#123;</span><br><span class="line">// 最近一次要匹配的字符串（Opera未实现）</span><br><span class="line">console.log(RegExp.input); // this is a wonderful year!</span><br><span class="line">console.log(RegExp.$_); // this is a wonderful year!</span><br><span class="line"></span><br><span class="line">// 最近的一次匹配（Opera未实现）</span><br><span class="line">console.log(RegExp.lastMatch); // wonderful</span><br><span class="line">console.log(RegExp[&apos;$&amp;&apos;]) // wonderful</span><br><span class="line"></span><br><span class="line">// 最近一次匹配的捕获组（Opera未实现）</span><br><span class="line">console.log(RegExp.lastParen); // ful</span><br><span class="line">console.log(RegExp[&quot;$+&quot;]); // full</span><br><span class="line"></span><br><span class="line">// 所有表达式都使用多行模式,boolean类型（nodejs,IE和Opera未实现）</span><br><span class="line">console.log(RegExp.multiline);</span><br><span class="line">console.log(RegExp[&apos;$*&apos;]);</span><br><span class="line"></span><br><span class="line">// input字符串中lastMatch之前的文本(Opera不支持短属性名）</span><br><span class="line">console.log(RegExp.leftContext); // this is a </span><br><span class="line">console.log(RegExp[&quot;$`&quot;]); // this is a </span><br><span class="line"></span><br><span class="line">// input字符串中lastMatch之后的文本(Opera不支持短属性名）</span><br><span class="line">console.log(RegExp.rightContext); // year!</span><br><span class="line">console.log(RegExp[&quot;$&apos;&quot;]); // year!</span><br><span class="line"></span><br><span class="line">// 还有9个用来存储捕获组的属性名别是RegExp.$1, RegExp.$2 ... RegExp.$9，调用exec或text函数时这些属性会被自动填充。</span><br><span class="line">console.log(RegExp.$1); // won</span><br><span class="line">console.log(RegExp.$2); // ful</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><p>String类型中也有一些函数可以使用正则表达式的能力。</p><h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p>String类型具有match函数，接收一个正则表达式作为参数，如果正则表达式没有g标识时，返回值和调用后RegExp的exec函数相同。在执行match函数后，RegExp函数的input、lastMatch、input、leftContext等静态属性同样会被填充</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var text = &apos;cat, bat, sat, fat&apos;;</span><br><span class="line">var pattern = /(.)at/;</span><br><span class="line"></span><br><span class="line">var matches = text.match(pattern);</span><br><span class="line">console.log(matches.index); // 0</span><br><span class="line">console.log(matches[0]); // cat</span><br><span class="line">console.log(matches[1]); // c</span><br><span class="line">console.log(pattern.lastIndex); // 0</span><br><span class="line">console.log(RegExp.input); // cat, bat, sat, fat</span><br><span class="line">console.log(RegExp.lastMatch); // cat</span><br><span class="line">console.log(RegExp.leftContext); //</span><br><span class="line">console.log(RegExp.rightContext); // , bat, sat, fat</span><br></pre></td></tr></table></figure><p>当正则表达式中有g标识符并成功匹配的时，match函数返回一个普通数组，里面保存有所有的匹配字串。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var text = &apos;cat, bat, sat, fat&apos;;</span><br><span class="line">var pattern = /(.)at/g;</span><br><span class="line"></span><br><span class="line">var matches = text.match(pattern);</span><br><span class="line">console.log(matches); // [ &apos;cat&apos;, &apos;bat&apos;, &apos;sat&apos;, &apos;fat&apos; ]</span><br><span class="line">console.log(matches[0]); // cat</span><br><span class="line">console.log(matches[1]); // bat</span><br><span class="line">console.log(matches[2]); // sat</span><br><span class="line">console.log(pattern.lastIndex); // 0</span><br><span class="line">console.log(RegExp.input); // cat, bat, sat, fat</span><br><span class="line">console.log(RegExp.lastMatch); // cat</span><br><span class="line">console.log(RegExp.leftContext); // fat</span><br><span class="line">console.log(RegExp.rightContext); // cat, bat, sat,</span><br></pre></td></tr></table></figure><p></p><h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><p>String类型search方法接收一个正则表达式参数，如果字符串与正则匹配时，返回第一个匹配的位置，如果不匹配，返回-1<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var text = &apos;cat, bat, sat, fat&apos;;</span><br><span class="line">var pattern = /at/;</span><br><span class="line">console.log(text.search(pattern)); // 1</span><br></pre></td></tr></table></figure><p></p><h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p>String类型replace函数可以方便的替换字符串内容并返回替换后的新字符串，该函数接收两个参数。<br>参数1: 一个字符串或一个正则表达式，使用字符串只能替换第一个匹配项，如果想要替换所有的匹配字串，只能通过传入一个具有g标识的正则表达式<br>参数2: 一个字符串或一个函数，用来替换匹配的内容<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var text = &apos;cat, bat, sat, fat&apos;;</span><br><span class="line">console.log(text.replace(&apos;at&apos;, &apos;ond&apos;)); // cond, bat, sat, fat</span><br><span class="line">console.log(text.replace(/at/g, &apos;ond&apos;)); // cond, bond, sond, fond</span><br></pre></td></tr></table></figure><p></p><p>当第二个参数为字符串时，还可以使用一些特殊的字符序列,通过这些字符序列，可以使用最后一次匹配结果中的内容。</p><table><thead><tr><th>字符序列</th><th>含意</th></tr></thead><tbody><tr><td>$$</td><td>$</td></tr><tr><td>$&amp;</td><td>匹配整个模式的子字符串，与RegExp.lastMatch的值相同</td></tr><tr><td>$’</td><td>匹配的子字符串之前的子字符串。与RegExp.leftContext的值相同</td></tr><tr><td>$`</td><td>匹配的子字符串之后的子字符串。与RegExp.rightContext的值相同</td></tr><tr><td>$n</td><td>匹配第n个捕获组的子字符串。其中n为1～99的数字</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var text = &apos;cat, bat, sat, fat&apos;;</span><br><span class="line">console.log(text.replace(/(.a)(t)/g, &apos;word ($1$2)&apos;));</span><br></pre></td></tr></table></figure><p>当第二个参数为函数时，该函数接受的参数依次是 匹配的子串、第一个捕获组、第二个捕获组、 … 、匹配到的子串在原位置的偏移量、被匹配的原字符。该函数需要返回一个字符串类型的值。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function htmlEscape(text) &#123;</span><br><span class="line">return text.replace(/[&lt;&gt;&quot;&amp;]/g, function (match, pos, originalText) &#123;</span><br><span class="line">switch (match) &#123;</span><br><span class="line">case &apos;&lt;&apos;:</span><br><span class="line">return &apos;&amp;lt;&apos;;</span><br><span class="line">case &apos;&gt;&apos;: </span><br><span class="line">return &apos;&amp;gt;&apos;;</span><br><span class="line">case &apos;&amp;&apos;:</span><br><span class="line">return &apos;&amp;amp;&apos;;</span><br><span class="line">case &apos;&quot;&apos;: </span><br><span class="line">return &apos;&amp;quot;&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(htmlEscape(&apos;&lt;p class=&quot;greeting&quot;&gt; Hello world! &lt;/p&gt;&apos;)); // &amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt; Hello world! &amp;lt;/p&amp;gt;</span><br></pre></td></tr></table></figure><p></p><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>String类型的split函数可以将一个字符串按指定的切分符切分成一系列的子串并以数组形式返回，该函数第一个参数为分隔符，可以是字符串类型也可以是正则表达式，第二个可选参数是一个整型，用来限制所需要返回数组的最大长度。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var pattern = /.a/i;</span><br><span class="line">var text = &apos;my name is NAT&apos;;</span><br><span class="line">console.log(text.split(pattern)); // [ &apos;my &apos;, &apos;me is &apos;, &apos;T&apos; ]</span><br></pre></td></tr></table></figure><p></p><h2 id="ES6变更与新增"><a href="#ES6变更与新增" class="headerlink" title="ES6变更与新增"></a>ES6变更与新增</h2><h3 id="u标识"><a href="#u标识" class="headerlink" title="u标识"></a>u标识</h3><p>在ES6之前字符串都是使用16位（UTF-16）字符编码的，在过去16位足以包含任何字符，直到Unicode引入扩展字符集，字符长度限制在16位将不足以表示这么多的字符，编码规则才不得不进行变更，在UTF-16中前2的16次方个码位均以16位编码单元表示，这个范围被称为基本多文种平面（BMP），超出这个范围的要归属于某个辅助平面，因为其中的码位仅用16位无法表示，UTF-16引入的代理对，其规定使用两个16位编码单元表示一个码位。所以现在的js字符串中有两种字符，一种是由一个编码单元16位表示的BMP字符，另一种是有32位表示的辅助平面字符。ES5中的对字符串操作都是针对16位编码单元的，如果同样对包含代理对的字符串进行使用，可能结果会与预期不符，正则表达式中新增了u标识来正确匹配包含代理对的字符。同时也为正则表达式增加了unicode属性用来判断正则表达式有没有u标识符。另一新增属性是flags，用于查看正则表达式的所有标识。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;𠮷&apos;; // 注意这是一个日语字符，并不是吉利的吉，读音是yoshi（同理，𠮷野家并不读 ’ji ye jia‘，因为第一个字是日文符号，发音是yoshi...）</span><br><span class="line">var pattern = /^.$/;</span><br><span class="line">console.log(pattern.test(s)); // false</span><br><span class="line">console.log(pattern.unicode); // false</span><br><span class="line">console.log(pattern.flags); // </span><br><span class="line"></span><br><span class="line">var pattern = /^.$/u;</span><br><span class="line">console.log(pattern.test(s)); // true</span><br><span class="line">console.log(pattern.unicode); // true</span><br><span class="line">console.log(pattern.flags); // u</span><br></pre></td></tr></table></figure><p></p><h3 id="y标识"><a href="#y标识" class="headerlink" title="y标识"></a>y标识</h3><p>ES6新增了y标识，使用y修饰符后，会从正则表达式的lastIndex处开始匹配，匹配失败将不再继续匹配，需要注意的是y标识只对正则表达式的exec和test方法有效，对字符串的方法无效；如果正则表达式中含有^且lastIndex的值不为0时，表达式会永远都不会匹配成功。<br>可以通过正则表达式的sticky属性来判断表达式是否有y标识。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var text = &apos;hello hexo.&apos;;</span><br><span class="line">var pattern1 = /h/g;</span><br><span class="line">console.log(&apos;sticky&apos;, pattern1.sticky); // sticky false</span><br><span class="line">console.log(pattern1.test(text)); // true</span><br><span class="line">pattern1.lastIndex = 2;</span><br><span class="line">console.log(pattern1.test(text)); // true</span><br><span class="line"></span><br><span class="line">var pattern2 = /h/gy;</span><br><span class="line">console.log(&apos;sticky&apos;, pattern2.sticky); // sticky true</span><br><span class="line">console.log(pattern2.test(text)); // true</span><br><span class="line">pattern2.lastIndex = 2;</span><br><span class="line">console.log(pattern2.test(text)); // false</span><br></pre></td></tr></table></figure><p></p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>在ES5中，可以给RegExp构造函数传递一个正则表达式来复制此表达式，如果第一个参数是正则表达式时，不允许有第二个参数，否则会报错，在ES6中，可以给第二个字符类型的参数用作创建的表达式的标识。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var pattern = /hello/i;</span><br><span class="line">console.log(pattern.toString()); // /hello/i</span><br><span class="line">console.log(pattern.test(&apos;Hello world&apos;)); // true</span><br><span class="line">// 在ES5中会报错，ES6中可以正常执行</span><br><span class="line">var pattern = new RegExp(pattern, &apos;gmu&apos;);</span><br><span class="line">console.log(pattern.toString()); // /hello/gmu</span><br><span class="line">console.log(pattern.test(&apos;Hello world&apos;)); // false</span><br></pre></td></tr></table></figure><p></p><h2 id="兼容性问题"><a href="#兼容性问题" class="headerlink" title="兼容性问题"></a>兼容性问题</h2><h3 id="新增标识"><a href="#新增标识" class="headerlink" title="新增标识"></a>新增标识</h3><p>在ES6之前的运行环境中使用标识u/y会导致执行错误，在使用前应该先确认执行环境是否支持u/y标识<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function hasRegExpU() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">var pattern = new RegExp(&apos;.&apos;, &apos;u&apos;);</span><br><span class="line">return true;</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (hasRegExpU()) &#123;</span><br><span class="line">//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>在在ES3中使用使用字面量方式创建的正则表达式会共用同一个RegExp实例，在ES5后就没有这一问题了(IE9+);<br>因此ES3中，字面量会使用同一个RegExp实例, 会导致下面两个打印结果是不同的，<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let regExpression;</span><br><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">regExpression = /cat/gi;</span><br><span class="line">console.log(regExpression.test(&apos;catastrophe&apos;));</span><br><span class="line">&#125;</span><br><span class="line">// 使用new操作符每次创建一个新实例</span><br><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">regExpression = new RegExp(&apos;cat&apos;, &apos;gi&apos;);</span><br><span class="line">console.log(regExpression.test(&apos;catastrophe&apos;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="正则表达式的限制"><a href="#正则表达式的限制" class="headerlink" title="正则表达式的限制"></a>正则表达式的限制</h2><ul><li>匹配字符串开始和结尾的\A和\Z锚，但完全支持以插入符（^）和美元符($)来匹配字符串的开始和结尾</li><li>向后查找(lookbehind),但完全支持lookahead</li><li>并集和交集类</li><li>原子组(atomic grouping)</li><li>Unicode支持(单个字符除外，入\uFFFF)</li><li>命名的捕获组，但支持编号的捕获组</li><li>s（single，单行）和x（free-spacing，无间隔）匹配模式</li><li>条件匹配</li><li>正则表达式注解</li></ul><h2 id="最后补充"><a href="#最后补充" class="headerlink" title="最后补充"></a>最后补充</h2><p>正则表达式的toLocalString() 和 toString() 方法都会返回正则表达式的字面量，与创建方式无关，valueOf函数返回表达式本身</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;字符串操作在我们编程中是经常会接触到的，正则表达式是一把操作字符串的利器，我们今天就来罗列一下js正则相关的api。&lt;/p&gt;&lt;h2 id=&quot;创建&quot;&gt;&lt;a href=&quot;#创建&quot; class=&quot;headerlink&quot; title=&quot;创建&quot;&gt;&lt;/a&gt;创建&lt;/h2&gt;&lt;p&gt;js中提供
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js继承</title>
    <link href="http://blog.zhanghuiliang.cn/2019/05/07/js%E7%BB%A7%E6%89%BF/"/>
    <id>http://blog.zhanghuiliang.cn/2019/05/07/js继承/</id>
    <published>2019-05-07T14:14:37.000Z</published>
    <updated>2019-05-07T14:14:37.829Z</updated>
    
    <content type="html"><![CDATA[<p>js语言是一种面向对象的语言，所谓的封装、继承、多态等特征js也都具备，这篇文章中我们就来探讨一下js中的继承有哪些实现方式。</p><p>如果有java、c++、oc等语言的基础的话会有一种观念，继承是基于与类的，需要说明的是js中的继承并不是基于类来实现的，而是基于原型的，尽管在ES6中有了class关键字，但在运行时中还是基于原型链来实现的。</p><h2 id="原型的概念"><a href="#原型的概念" class="headerlink" title="原型的概念"></a>原型的概念</h2><p>在js中创建对象典型是通过new操作符来调用构造函数，得到的实例中会有一个[[prototype]]的私有属性，这个私有属性是一个构造函数的prototype属性的一个引用。查找实例属性时会先在自身查找，然后再去查找[[prototype]]，直到查找成功或[[prototype]]为空。这就是原型的基本原理。在ES6之前我们都是通过对构造函数和原型来达到继承的效果。以下我们来列举一下大概会有多少种继承的实践。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>我们知道了对一个对象进行属性查找时如果在自身查找不到时会去原型中进行查找，如果仍然查找不到的话又会继续查找原型的原型，如此反复直至查找成功或没有更深层次的原型可供查找，基于这种原理，我们可以通过将被继承类型的实例作为子类型的原型即是一种实现继承的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function SuperType() &#123;</span><br><span class="line">    this.flag = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = function () &#123;</span><br><span class="line">    return this.flag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function SubType() &#123;</span><br><span class="line">    this.subflag = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//继承了 Super</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype .getSubValue = function () &#123;</span><br><span class="line">    return this.subflag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType();</span><br><span class="line">console.log(instance1.getSuperValue()); // true</span><br><span class="line">console.log(instance1.getSubValue()); // false</span><br><span class="line"></span><br><span class="line">console.log(instance1 instanceof SubType); // true</span><br><span class="line">console.log(instance1 instanceof SuperType);// true</span><br><span class="line">console.log(instance1 instanceof Object); // true</span><br><span class="line"></span><br><span class="line">console.log(Object.prototype.isPrototypeOf(instance1)); // true</span><br><span class="line">console.log(SuperType.prototype.isPrototypeOf(instance1));// true</span><br><span class="line">console.log(SubType.prototype.isPrototypeOf(instance1)); // true</span><br><span class="line"></span><br><span class="line">console.log(instance1.constructor); // [Function: SuperType]</span><br></pre></td></tr></table></figure><p>根据上面代码可以看出通过将子类型的构造函数的prototype设置为父类型实例，实例化的子类型可以同时拥有子类型和父类型的属性，也就是说我们通过这种方式实现了继承，不过这种继承有一些缺点,原型链中有引用类型的属性时，该属性会被所有实例所共用，这就会造成如果有任何一个实例如果更改了原型中的应用类型的值就会影响到其他实例；再者就是在构造子类型实例时，无法向超类的构造函数中传递参数。</p><h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p>js函数有一个call方法，调用时指定的第一个参数为函数的作用域对象，其后参数会作为调用函数的参数进行传递，使用构造函数模式定义的构造函数内部我们会将要定义的属性赋值给作用域对象（this），基于上面两点，我们可以在子类型的构造函数中使用父类型的call函数，把当前的this作为第一个参数传入，以此来获得父类型的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function SubType(name, age) &#123;</span><br><span class="line"></span><br><span class="line">    //继承 SuperType</span><br><span class="line">    SuperType.call(this, name);</span><br><span class="line"></span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType(&quot;Bill&quot;, 22); </span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line"></span><br><span class="line">console.log(instance1.name); // Bill</span><br><span class="line">console.log(instance1.age); // 22</span><br><span class="line">console.log(instance1.colors); // [ &apos;red&apos;, &apos;blue&apos;, &apos;green&apos;, &apos;black&apos; ]</span><br><span class="line"></span><br><span class="line">var instance2 = new SubType(&quot;Annie&quot;, 24);</span><br><span class="line">console.log(instance2.name); // Annie</span><br><span class="line">console.log(instance2.age); // 24</span><br><span class="line">console.log(instance2.colors); // [ &apos;red&apos;, &apos;blue&apos;, &apos;green&apos; ]</span><br><span class="line">console.log(instance2.sayName); // undefined</span><br><span class="line"></span><br><span class="line">var super1 = new SuperType();</span><br><span class="line">console.log(super1.sayName); // [Function]</span><br></pre></td></tr></table></figure><p>这种方法的优点是，父类型中的引用类型的属性,并不被所有实例所公用，不会有有互相串改数据的问题；在构造子类型的实例时,可以向超类的构造函数中传递参数。不过如果父类型中的函数是定义在父类型实例中的话（典型的构造函数模式就是这样），子类型个实例之间无法复用函数，如果父类型中的函数是定义在父类型原型上的，子类型中根本就继承不到，因为子类型中实例的[[prototype]]是指向子类型的构造函数的prototype的，在子类型实例中没有指向父类型prototype的指针，所以也就没继承到。</p><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合原型链和借用构造函数两者的优点，使用原型链来继承父类型中的原型属性进行继承，使用构造函数对父类型的实例属性进行继承</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function SubType(name, age) &#123;</span><br><span class="line"></span><br><span class="line">    //继承 SuperType</span><br><span class="line">    SuperType.call(this, name);</span><br><span class="line"></span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">SubType.prototype.sayAge = function () &#123;</span><br><span class="line">    console.log(this.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var instance1 = new SubType(&quot;Bill&quot;, 22);</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line"></span><br><span class="line">instance1.sayName(); // Bill</span><br><span class="line">instance1.sayAge(); // 22</span><br><span class="line">console.log(instance1.colors); // [ &apos;red&apos;, &apos;blue&apos;, &apos;green&apos;, &apos;black&apos; ]</span><br><span class="line"></span><br><span class="line">var instance2 = new SubType(&quot;Annie&quot;, 24);</span><br><span class="line">instance2.sayName(); // Annie</span><br><span class="line">instance2.sayAge(); // 24</span><br><span class="line">console.log(instance2.colors); // [ &apos;red&apos;, &apos;blue&apos;, &apos;green&apos; ]</span><br><span class="line"></span><br><span class="line">console.log(instance1 instanceof Object); // true</span><br><span class="line">console.log(instance1 instanceof SuperType); // true</span><br><span class="line">console.log(instance1 instanceof SubType); // true</span><br><span class="line"></span><br><span class="line">console.log(Object.prototype.isPrototypeOf(instance1)); // true</span><br><span class="line">console.log(SuperType.prototype.isPrototypeOf(instance1)); // true</span><br><span class="line">console.log(SubType.prototype.isPrototypeOf(instance1)); // true</span><br></pre></td></tr></table></figure><p>组合了两种模式之后，避免了原型链和借用构造函数的缺陷,融合了他们的优点。成为JS中最常用的继承方式。仅有一点小不足就是调用了两次父类的构造函数,在子类的prototype上面创建了不必要的、多余的属性</p><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>原型式继承的原理是将一个对象直接作为新对象的原型，使用这种模式创建的对象并没有自定义的类型，只是实现了在原有对象的基础上进行了扩展。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function object(o) &#123;</span><br><span class="line">    function F() &#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;Bill&quot;,</span><br><span class="line">    friends: [&quot;Annie&quot;, &quot;Frank&quot;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var antherPerson = object(person);</span><br><span class="line">antherPerson.name = &quot;Greg&quot;;</span><br><span class="line">antherPerson.friends.push(&quot;Rob&quot;);</span><br><span class="line"></span><br><span class="line">console.log(person.name); // Bill</span><br><span class="line">console.log(person.friends); // [ &apos;Annie&apos;, &apos;Frank&apos;, &apos;Rob&apos; ]</span><br><span class="line"></span><br><span class="line">console.log(antherPerson.name); // Greg</span><br><span class="line">console.log(antherPerson.friends); // [ &apos;Annie&apos;, &apos;Frank&apos;, &apos;Rob&apos; ]</span><br></pre></td></tr></table></figure><p>这种模式确实可以创建出基于其他对象的实例，不过在原型链中有引用类型的属性时，该属性会被所有实例所共用;还有一个问题就是在构造子类型的实例时，无法向父类型的构造函数中传递参数。</p><p>在ES5中新增了Object.create函数，该函数规范了原型式继承的，该函数接收两个参数，原型对象以及一个可选的为新对象定义额外属性的属性描述符对象（和Object.defineProperties方法第二个参数一样）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var antherPerson2 = Object.create(person, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: &quot;Frank&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">antherPerson2.friends.push(&quot;Shelby&quot;);</span><br><span class="line">console.log(antherPerson2.name); // Frank</span><br><span class="line">console.log(antherPerson2.friends); // [ &apos;Annie&apos;, &apos;Frank&apos;, &apos;Rob&apos;, &apos;Shelby&apos; ]</span><br><span class="line">console.log(antherPerson.friends); // [ &apos;Annie&apos;, &apos;Frank&apos;, &apos;Rob&apos;, &apos;Shelby&apos; ]</span><br></pre></td></tr></table></figure><p>总体来说，有了Object.create函数可以是我们更加便捷的使用原型式继承，不过由于引用类型的值会被所有新创建的实例所用，这种模式个人感觉使用时还是需要比较谨慎。</p><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>寄生式继承是将原型式继承使用一个工厂函数将构建过程封装起来，在工程函数中可以为创建的新对象添加所需的新的属性，最后返回新对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function createAnother(original) &#123;</span><br><span class="line">    function object(o) &#123;</span><br><span class="line">        function F() &#123;&#125;</span><br><span class="line">        F.prototype = o;</span><br><span class="line">        return new F();</span><br><span class="line">    &#125;</span><br><span class="line">    var clone = object(original);</span><br><span class="line">    // var clone = Object.create(original);</span><br><span class="line"></span><br><span class="line">    clone.sayName = function () &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Person(name, friends) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.friends = friends;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person(&quot;Bill&quot;, [&quot;Annie&quot;, &quot;Frank&quot;]);</span><br><span class="line"></span><br><span class="line">var anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.name = &quot;Greg&quot;;</span><br><span class="line">anotherPerson.friends.push(&quot;Rob&quot;);</span><br><span class="line">anotherPerson.sayName(); // Greg</span><br><span class="line"></span><br><span class="line">var anotherPerson1 = createAnother(person);</span><br><span class="line">console.log(anotherPerson.sayName == anotherPerson1.sayName); // false</span><br></pre></td></tr></table></figure><p>这种模式相对于原型模式封装程度更高一点，使用这种模式创建的实例之间不能复用函数，效率会降低。</p><h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>组合继承是最常用的继承方式，不过他会调用两次父类型的构造函数，形成在实例自身和原型上分别形成一份属性，寄生组合式继承利用构造函数来继承实例属性，通过引用一份父类型引用来获得原型链。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function inheritPrototype(subType, superType) &#123;</span><br><span class="line">    var prototype = Object(superType.prototype);</span><br><span class="line">    prototype.constructor = subType;</span><br><span class="line">    subType.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SuperType(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function SubType(name, age) &#123;</span><br><span class="line"></span><br><span class="line">    //继承 SuperType</span><br><span class="line">    SuperType.call(this, name);</span><br><span class="line"></span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = function () &#123;</span><br><span class="line">    console.log(this.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType(&quot;Bill&quot;, 22);</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line"></span><br><span class="line">instance1.sayName(); // Bill</span><br><span class="line">instance1.sayAge(); // 22</span><br><span class="line">console.log(instance1.colors); // [ &apos;red&apos;, &apos;blue&apos;, &apos;green&apos;, &apos;black&apos; ]</span><br></pre></td></tr></table></figure><p></p><p>寄生组合式继承避免了调用两次父类型的构造函数，避免在子类的prototype上面创建不必要、多余的属性，是ES6之前最理想的继承范式。</p><h2 id="class-extends"><a href="#class-extends" class="headerlink" title="class extends"></a>class extends</h2><p>在ES6之前继承只能通过上面介绍的方法，使用函数，原型，各种组合的手段才能实现较为理想的继承方式，在ES6中js给出了class和extends操作符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class SuperType &#123;</span><br><span class="line">constructor(name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayName() &#123;</span><br><span class="line">console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SubType extends SuperType &#123;</span><br><span class="line">constructor(name, age) &#123;</span><br><span class="line">// 相当于SuperType.call(this, name);</span><br><span class="line">super(name);</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayAge() &#123;</span><br><span class="line">console.log(this.age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let instance1 = new SubType(&apos;Bill&apos;, 25);</span><br><span class="line">instance1.sayName(); // Bill</span><br><span class="line">instance1.sayAge(); // 25</span><br></pre></td></tr></table></figure><p>在定义SubType时要通过extends指明要继承的父类型，在子类型定义中可是使用super关键字来指示父类型，在constructor中调用super()函数向父类型构造函数传参,这是一个和寄生组合式等价的实现方式,在书写上和语义上都比ES5中要清晰很多，所以建议在实践中应该尽量使用class的extends关键字来实现继承。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;js语言是一种面向对象的语言，所谓的封装、继承、多态等特征js也都具备，这篇文章中我们就来探讨一下js中的继承有哪些实现方式。&lt;/p&gt;&lt;p&gt;如果有java、c++、oc等语言的基础的话会有一种观念，继承是基于与类的，需要说明的是js中的继承并不是基于类来实现的，而是基于原型
      
    
    </summary>
    
    
      <category term="js" scheme="http://blog.zhanghuiliang.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js对象创建</title>
    <link href="http://blog.zhanghuiliang.cn/2019/05/05/js%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/"/>
    <id>http://blog.zhanghuiliang.cn/2019/05/05/js对象创建/</id>
    <published>2019-05-05T14:21:23.000Z</published>
    <updated>2019-05-05T14:21:23.451Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>创建一个对象最简单的方法莫过于使用字面量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var animalA = &#123;</span><br><span class="line">name: &apos;animal&apos;,</span><br><span class="line">age: 1,</span><br><span class="line">relations: [],</span><br><span class="line">run: function () &#123;</span><br><span class="line">console.log(&apos;run&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里我们创建了一个animalA对象，他具有三个属性，一个方法。这种创建对象的方法因为简单，所以也是较为常用的一种方法，不过一次只能创建出一个对象，也就是这里的animalA，如果要再次创建一个同样结构的animalB就需要重复写一遍后面的字面量，创建过程不能重用。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式是使用一个函数来封装对象的创建过程，每次创建对象是就通过对工厂方法的调用来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function createAnimal(name, age) &#123;</span><br><span class="line">var animal = &#123;&#125;;</span><br><span class="line">animal.name = name;</span><br><span class="line">animal.age = age;</span><br><span class="line">animal.relations = [];</span><br><span class="line">animal.run = function () &#123;</span><br><span class="line">console.log(&apos;run&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">return animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var animalA = createAnimal(&apos;animalA&apos;, 1);</span><br><span class="line">var animalB = createAnimal(&apos;animalB&apos;, 2);</span><br><span class="line"></span><br><span class="line">console.log(animalA.constructor, animalB.constructor); // Object() &#123;&#125;, Object() &#123;&#125;</span><br></pre></td></tr></table></figure><p>这里我们定义了一个createAnimal函数，每次调用即可返回一个具有3个属性，一个方法的对象。工厂模式规避了字面量方式创建相似对象时比较繁琐的问题，但是他没有产生对象类型标示，通过打印animalA和animalB的constructor可以发现输出的都是Object。</p><h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><p>在js中，可以通过函数名前添加new操作符来创建对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Animal (name, age) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">this.relations = [];</span><br><span class="line">this.run = function () &#123;</span><br><span class="line">console.log(&apos;run&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var animalA = new Animal(&apos;animalA&apos;, 1);</span><br><span class="line">var animalB = new Animal(&apos;animalB&apos;, 2);</span><br><span class="line"></span><br><span class="line">console.log(animalA.constructor); // Animal() &#123;&#125;</span><br><span class="line">console.log(animalA.run === animalB.run); // false</span><br></pre></td></tr></table></figure><p>使用new操作符调用函数时，运行环境会创建一个新对象，然后将构造函数的作用域赋给新对象（this也就指向这个新对象），运行函数，在函数运行结束后如果没有显式的return值，就会将创建的这个新对象作为返回值返回。</p><p>使用构造函数可以重用创建过程，创建的对象具有相同的类型标识（constructor），不过我们对比初始化出的两个实例的run方法会发现它们并不相等，也就是说每次每个实例对象都独立拥有一个自己的run方法，这显然是不够经济且不符合我们对它们的一致性的期望。</p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>js函数具有一个prototype属性，使用函数名前加new操作符创建的实例内部会有一个[[prototype]]指针指向构造函数的prototype属性,访问实例的属性时会先对实例自身进行查找，如果查找不到会继续查找实例的[[prototype]]，查找仍然失败就继续查找[[prototype]]的[[prototype]]，依此规则持续进行直到查找成功或失败。所以，将属性放在函数的prototype属性上可以实现实例之间共享数据的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Animal() &#123;&#125;</span><br><span class="line">Animal.prototype.name = &apos;&apos;;</span><br><span class="line">Animal.prototype.age = 0;</span><br><span class="line">Animal.prototype.relations = [];</span><br><span class="line">Animal.prototype.run = function() &#123;</span><br><span class="line">console.log(&quot;run&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var animalA = new Animal();</span><br><span class="line">var animalB = new Animal();</span><br><span class="line"></span><br><span class="line">console.log(animalA instanceof Animal); // true</span><br><span class="line">console.log(animalA.run === animalB.run); // true</span><br><span class="line">console.log(animalA.relations); // []</span><br><span class="line">animalB.relations.push(&apos;fish&apos;);</span><br><span class="line">console.log(animalA.relations); // [&apos;fish&apos;]</span><br></pre></td></tr></table></figure><p>使用原型模式由于所创建的实例的[[prototype]]都指向的是Animal.prototype，所以可以看到他避免了构造函数模式两次创建的实例的run函数不相等的问题，但是原型上的其他引用类型的属性也被共用，因此导致了一个实例更改了原型中引用类型的数据，其他实例访问数据也会变化。</p><h2 id="组合构造函数和原型模式"><a href="#组合构造函数和原型模式" class="headerlink" title="组合构造函数和原型模式"></a>组合构造函数和原型模式</h2><p>仅使用构造函数实例间不能重用函数，仅使用原型模式重用的函数的同时也会导致引用类型的值的重用，因此不难想象我们可以组合使用两者。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Animal(name, age) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">this.relations = [];</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.run = function () &#123;</span><br><span class="line">console.log(&apos;run&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var animalA = new Animal(&apos;dog&apos;, 1);</span><br><span class="line">var animalB = new Animal(&apos;cat&apos;, 1);</span><br><span class="line"></span><br><span class="line">console.log(animalA.run === animalB.run);// true</span><br><span class="line">console.log(animalA.relations); // []</span><br><span class="line">animalB.relations.push(&apos;fish&apos;);</span><br><span class="line">console.log(animalA.relations); // []</span><br></pre></td></tr></table></figure><p></p><p>组合使用了构造函数模式和原型模式后，解决了对象类型标示问题，可以重用constructor和其他函数,这是一个典型的对象创建的范例。</p><h2 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h2><p>构造函数模式和原型模式组合使用后确实是一种不错的实践方式，不过在为构造函数的原型添加函数的代码在构造函数之外，这自然是给人一种封装不足的感觉，我们可以通过在构造函数内部,对函数原型是否已经赋值的判断来动态的添加原型方法,从而实现进一步的封装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Animal(name, age) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">this.relations = [];</span><br><span class="line">if (!Animal.prototype.run) &#123;</span><br><span class="line">Animal.prototype.run = function () &#123;</span><br><span class="line">console.log(&apos;run&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var animalA = new Animal(&apos;dog&apos;, 1);</span><br><span class="line">var animalB = new Animal(&apos;cat&apos;, 1);</span><br><span class="line"></span><br><span class="line">console.log(animalA.constructor); // Animal() &#123;&#125;</span><br><span class="line">console.log(animalA.run === animalB.run);// true</span><br><span class="line">console.log(animalA.relations); // []</span><br><span class="line">animalB.relations.push(&apos;fish&apos;);</span><br><span class="line">console.log(animalA.relations); // []</span><br></pre></td></tr></table></figure><p>通过代码可以看到，我们将在原型上添加函数的代码移至函数内部，通过最初的一次判断来确定为原型添加函数的逻辑只会在构造函数第一次被调用时执行。动态原型模式可以理解为是组合构造函数和原型模式的另一种写法。</p><h2 id="寄生构造函数"><a href="#寄生构造函数" class="headerlink" title="寄生构造函数"></a>寄生构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Animal(name, age) &#123;</span><br><span class="line">var animal = &#123;&#125;;</span><br><span class="line">animal.name = name;</span><br><span class="line">animal.age = age;</span><br><span class="line">animal.relations = [];</span><br><span class="line">animal.run = function () &#123;</span><br><span class="line">console.log(&apos;run&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">return animal;</span><br><span class="line">&#125;</span><br><span class="line">var animalA = new Animal(&apos;dog&apos;, 1);</span><br><span class="line">var animalB = new Animal(&apos;cat&apos;, 1);</span><br><span class="line"></span><br><span class="line">console.log(animalA.constructor); // Object() &#123;&#125;</span><br><span class="line">console.log(animalA instanceof Animal); // false</span><br></pre></td></tr></table></figure><p>寄生构造函数除了使用new操作符调用和把函数叫做构造函数外，看起来跟工厂模式没有任何区别。寄生构造函数模式创建的实例与构造函数的原型属性之间没有关系，所以实例的constructor并不指向构造函数，也无法使用instanceof来判断实例的类型。正常情况下不推荐使用，除非你要为已有类型扩展功能（装潢模式）,比如:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function SpecialArray() &#123;</span><br><span class="line">var array = new Array();</span><br><span class="line">array.push.apply(array, arguments);</span><br><span class="line">array.toPipedString = function () &#123;</span><br><span class="line">return this.join(&quot;|&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">return array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var colors = new SpecialArray(&apos;red&apos;, &apos;blue&apos;, &apos;grey&apos;);</span><br><span class="line">console.log(colors.toPipedString()); // red|blue|grey</span><br></pre></td></tr></table></figure><p></p><h2 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h2><p>Douglas Crockford发明了JavaScript中的稳妥对象的概念，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象适用于一些安全的环境中（禁止使用new和this），稳妥构造函数和寄生构造函数类似，但有亮点不同，一是新创建对象的实例方法中不使用this，二是不使用new操作符调用构造函数。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Animal(name, age) &#123;</span><br><span class="line">var animal = &#123;&#125;;</span><br><span class="line">animal.run = function () &#123;</span><br><span class="line">console.log(name + &apos; run&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">return animal;</span><br><span class="line">&#125;</span><br><span class="line">var animalA = new Animal(&apos;dog&apos;, 1);</span><br><span class="line">animalA.run();</span><br></pre></td></tr></table></figure><p></p><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>ES6中新添加了class关键字，可以通过class来定义类，通过对类进行实例化来创建对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">constructor(name, age) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run() &#123;</span><br><span class="line">console.log(&apos;run&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static hello() &#123;</span><br><span class="line">console.log(&apos;hello&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(typeof Animal); // function</span><br><span class="line">var animalA = new Animal(&apos;dog&apos;, 1);</span><br><span class="line">console.log(typeof animalA); // object</span><br><span class="line">console.log(animalA.constructor); // class Animal1&#123;&#125;</span><br><span class="line">console.log(animalA instanceof Animal); // true</span><br></pre></td></tr></table></figure><p>使用class关键字后面跟类名，跟大括号，在大括号中名为constructor的函数就是构造函数，实例属性可以在constructor中进行初始化，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;字面量&quot;&gt;&lt;a href=&quot;#字面量&quot; class=&quot;headerlink&quot; title=&quot;字面量&quot;&gt;&lt;/a&gt;字面量&lt;/h2&gt;&lt;p&gt;创建一个对象最简单的方法莫过于使用字面量：&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo使用</title>
    <link href="http://blog.zhanghuiliang.cn/2019/04/25/hexo%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.zhanghuiliang.cn/2019/04/25/hexo使用/</id>
    <published>2019-04-25T12:54:14.000Z</published>
    <updated>2019-04-26T08:25:28.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>在说hexo之前要先说一下写博客过程，我们要写一篇博客时通常采用Markdown格式的文件，简单来说，Markdown就是通过简单的对文本进行标记来实现一些页面布局效果的一种方案。一篇Markdown格式的文章写完后，再把Markdown格式转化成html格式的文件用来网站部署，到这里就可以说一下hexo了。</p><p>hexo是一款基于nodejs平台的博客类网站生成工具，使用hexo可以帮我们方便组织我们的Markdown文件、可以帮我们把Markdown格式的文章生成静态html页面、通过插件还可以帮我们把生成的html页面部署到生产环境。</p><p>下面我们就来说一下hexo从安装,到写作,到部署至<a href="https://pages.github.com" target="_blank" rel="noopener">GitHub Pages</a>的过程,由于本文主要是对hexo的简单描述，所以本文章默认你已经安装了nodejs，并且对github有所了解（新建仓库），这里对这些概念不再展开描述了。</p><h2 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h2><p>使用hexo之前要先全局安装hexo的命令行工具：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装完成hexo之后系统就会有一个hexo的命令行工具可以使用，可以使用下面三行命令来创建hexo’工程’;<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;   # 创建hexo工程,把&lt;folder&gt;替换成你想要的名字</span><br><span class="line"></span><br><span class="line">$ cd &lt;folder&gt;          # 进入工程目录</span><br><span class="line"></span><br><span class="line">$ npm install       # 安装项目依赖</span><br></pre></td></tr></table></figure><p></p><p>为了后面的叙述方便，我们需要的一些hexo的插件在这里也一气呵成都安装上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-all-minifier  # 一个可以把生成的网页文件进行压缩，有利于提升网站的访问速度</span><br><span class="line"></span><br><span class="line">$ npm install hexo-deployer-git  # 一个可以帮助我们部署网站的插件</span><br></pre></td></tr></table></figure><h2 id="hexo-项目目录结构"><a href="#hexo-项目目录结构" class="headerlink" title="hexo 项目目录结构"></a>hexo 项目目录结构</h2><p>到目前为止，我们的hexo工程已经创建完毕，下面对hexo项目的重要的几个目录以及文件做一下介绍：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_config.yml     # 项目的配置文件</span><br><span class="line">public          # 生成的网站文件，稍后部署博客网站也就是部署这个目录中的文件</span><br><span class="line">scaffolds       # 文章模版，创建新文章时可以选择的模版</span><br><span class="line">source          # 存放我们写的文章（Markdown）</span><br><span class="line">  _discarded        # 存放丢弃的文章，理解成垃圾娄把</span><br><span class="line">  _drafts           # 存放草稿，还没有完全写完的文章可以先放在这个目录下</span><br><span class="line">  _posts            # 存放我们要发布的文章，放在这个目录下的Markdown文件稍后都会生成对应的网页</span><br></pre></td></tr></table></figure><h2 id="常用的hexo命令"><a href="#常用的hexo命令" class="headerlink" title="常用的hexo命令"></a>常用的hexo命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;filename&gt;     # 新建一篇文章,layout指scaffolds目录中的模版文件，默认已经有draft、page、post可以选择，如果有需要的话你还可以继续新建模版;新建的文章会放在source/_posts 目录下，有一个例外就是layout设置为draft时文件会放在source/_drafts目录下。</span><br><span class="line"></span><br><span class="line">$ hexo publish [layout] &lt;filename&gt; # 发布草稿，会把source/_drafts目录下的文件转移到source/_posts目录下。</span><br><span class="line"></span><br><span class="line">$ hexo server                      # 开启一个可以预览生成的blog效果的服务。</span><br><span class="line"></span><br><span class="line">$ hexo generate                    # 生成网站，会生成source/_posts目录下文章对应的网页文件，网页文件放在public目录下。</span><br><span class="line"></span><br><span class="line">$ hexo deploy                      # 部署网站,部署方法下面会说</span><br></pre></td></tr></table></figure><h2 id="部署准备"><a href="#部署准备" class="headerlink" title="部署准备"></a>部署准备</h2><p>部署网站可以按照自己的喜好部署，在这里给出一种依赖github pages来进行部署的方案，github pages给提供了网站部署功能，使用方法是在github中创建以 ‘用户名.github.io’为名称的一个仓库，然后在这个仓库上传的文件可以通过’用户名.github.io’域名进行访问。创建步骤如下：</p><ol><li>登录 <a href="https://github.com/" target="_blank" rel="noopener">github</a>,如果没有账号的话就注册一个</li><li>创建一个git仓库，名称必须是‘&lt;你的github名称&gt;.github.io’</li><li>在仓库页面，点击’clone and downlowd’复制仓库地址，留作稍后部署之用（仓库链接是以.git结尾的那个链接，不是页面浏览器地址框中的链接哈）</li></ol><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>_config.yml是hexo的配置文件,详细的字段解释在这里也不再赘述，可以看官网的<a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">文档</a>，需要说一下的是关于部署的配置和我们对页面压缩插件的配置，打开_config.yml文件。</p><p>找到deploy选项：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">把deploy下的type配置为git</span><br><span class="line"></span><br><span class="line">repo 配置为刚才复制的github仓库地址</span><br><span class="line"></span><br><span class="line">配置好后大致长这样：</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: https://github.com/xxxx/xxxx.github.io.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure><p></p><p>在页面最底下添加：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_minifier: true # hexo-all-minifier 插件的配置</span><br></pre></td></tr></table></figure><p></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>截止目前为止，我们已经创建并设置好了hexo项目，使用以下两行命令即可完成部署:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate # 生成网站文件</span><br><span class="line">hexo deploy   # 部署网站,第一次会让输入github名称和密码</span><br></pre></td></tr></table></figure><p></p><p>部署成功后可以在浏览器中输入 ‘你的github名称.github.io’进行查看部署效果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>初接触hexo时，需要先进行hexo的安装，和配置，这些都搞定后以后使用中最常做的操作也就是通过<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &lt;filename&gt;</span><br></pre></td></tr></table></figure><p></p><p>创建文章，然后编辑source/_post目录下的文章，最后执行<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p></p><p>生成网站，并部署：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;p&gt;在说hexo之前要先说一下写博客过程，我们要写一篇博客时通常采用Markdown格式的文件，简单来说，Markdown就是通过简单的对文本进
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://blog.zhanghuiliang.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Macports使用简介</title>
    <link href="http://blog.zhanghuiliang.cn/2017/09/08/Macports/"/>
    <id>http://blog.zhanghuiliang.cn/2017/09/08/Macports/</id>
    <published>2017-09-08T02:34:10.000Z</published>
    <updated>2017-09-14T06:23:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://www.macports.org/" target="_blank" rel="noopener">Macports</a>是一款供Mac系统的包管理器，主要用来安装软件，卸载软件更新软件等。继续阅读之前需要按照<a href="https://www.macports.org/install.php" target="_blank" rel="noopener">官网</a>指示安装Macports.</p><p>如果使用官网提供的安装器安装，安装成功后，默认会将Macports拷贝到 <em>/opt/local</em>,执行文件将放在<em>/opt/local/bin</em>,其他文件会放在<em>/opt/local/var/macports</em>,最后会把目录<em>/opt/local</em>通过配置文件<em>~/.profile</em>添加到环境变量中(PATH)中。</p><p>可以通过:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ port version</span><br></pre></td></tr></table></figure><p></p><p>port是Macports的执行命令,上面的命令可以查看Macports的版本，如果成功输出如<em>Version: 2.4.1</em>滋字样，说明Macports已经安装成功了，否则就需要检查是否安装失败，或者环境变量添加失败。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><strong>1. 查看帮助</strong><br>可以通过linux man命令查看:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ man port</span><br><span class="line">$ man macports.conf</span><br></pre></td></tr></table></figure><p></p><p>Macports也提供了port help命令查看帮助文档:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查看port的帮助文档</span><br><span class="line">$ port help </span><br><span class="line"></span><br><span class="line">其后跟行为参数，可以查看行为的详细介绍，如：</span><br><span class="line">$ port help selfupdate</span><br></pre></td></tr></table></figure><p></p><p><strong>2. port selfupdate</strong><br>port命令后跟selfupdate指令可以更新Macports、本地Portfiles（保存服务器port信息的数据库）(因此安装成功后就应该检查更新一次)。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo port selfupdate</span><br></pre></td></tr></table></figure><p></p><p>selfupdate后可跟参数：</p><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>-d</td><td>开启debug模式，一旦命令执行错误，可以查看更多详细信息</td></tr><tr><td>–nosync</td><td>只更新Macports本身，不更新本地数据库</td></tr></tbody></table><p><strong>3. port diagnose</strong><br>检查运行环境常见问题，把发现的问题都列出来<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ port diagnose</span><br></pre></td></tr></table></figure><p></p><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>–quiet</td><td>只显示警告和错误，不显示执行脚本状态</td></tr></tbody></table><p><strong>4. port reclaim</strong><br>移除不活跃的软件<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ port reclaim</span><br></pre></td></tr></table></figure><p></p><p><strong>5. port list</strong><br>列出所有可以通过Macports安装的port的列表（不是已安装的列表）。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ port list</span><br></pre></td></tr></table></figure><p></p><p><strong>6. port search</strong></p><p>匹配名称／描述符合关键词的软件，如搜索php：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ port search php</span><br></pre></td></tr></table></figure><p></p><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>–glob</td><td>对给定的搜索字符串作为全局搜索的字符串（即扩展通配符*、？和[字符]。这是默认行为。</td></tr><tr><td>–regex</td><td>将给定搜索字符串视为正则表达式。</td></tr><tr><td>—line</td><td>指定每一个匹配的port信息在一行上输出</td></tr><tr><td>–case-sensitive</td><td>大小写敏感</td></tr><tr><td>field</td><td>测试搜索关键字与指定字段（field）进行匹配，默认匹配字段为 —name —description</td></tr></tbody></table><p>可用的field字段有：</p><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>–category, –categories</td><td>在指定分类中搜索</td></tr><tr><td>–depends, –depends_build, –depends_extract, –depends_fetch, –depends_lib, –depends_run</td><td>搜索所有依赖名为搜索关键字的port的port，–depends包含其他所有的–depends_ options。</td></tr><tr><td>–description, –long_description</td><td>对port的描述部分进行匹配</td></tr><tr><td>—homepage</td><td>对所有ports的homepage字段进行匹配</td></tr><tr><td>–maintainer, –maintainers</td><td>搜索某个维护者相关的ports</td></tr><tr><td>—name</td><td>只对port的名称进行匹配</td></tr><tr><td>–portdir</td><td>匹配包含在给定目录名下的port</td></tr><tr><td>–variant, –variants</td><td>搜索匹配关键字的变体</td></tr></tbody></table><p><strong>7. port info</strong><br>可以获取软件的信息，如（名称，版本，官网等），如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ port info nginx</span><br></pre></td></tr></table></figure><p></p><p><strong>8. port deps</strong><br>可以查询软件的依赖</p><p><strong>9. port variants</strong><br>port variants 查询新版本相对于已安装版本的差异</p><p><strong>10. port install</strong><br>安装软件，例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo port install apache2 -preforkmpm +workermpm</span><br></pre></td></tr></table></figure><p></p><p>安装apache2，不安装其中的preforkmpm，安装workermpm.<br>如果安装失败可以通过port logfile<portname>查看日志，sudo port clean<portname>清除安装失败的port。</portname></portname></p><p><strong>11. port clean</strong><br>清理安装过程中所产生的文件，在安装软件失败后经常会用到<br>sudo port clean<portname><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo port clean mysql56</span><br></pre></td></tr></table></figure></portname></p><p>参数：</p><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>–archive</td><td>清理临时压缩文件</td></tr><tr><td>–dist</td><td>清理下载的文件</td></tr><tr><td>–logs</td><td>清理日志文件</td></tr><tr><td>–work</td><td>清理安装进程所用目录，此目录是MacPorts构建软件所用，此选项是默认选项。</td></tr><tr><td>–all</td><td>清理所有</td></tr></tbody></table><p><strong>12. port uninstall</strong><br>卸载安装</p><p>格式:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo port uninstall &lt;portname&gt;</span><br></pre></td></tr></table></figure><p></p><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>–follow-dependents</td><td>Macports不会卸载还被依赖的port，此选项可以递归卸载安装，比如B 依赖A，卸载A默认是不可以的，使用此选项可以先卸载B，再卸载A。</td></tr><tr><td>–follow-dependencies</td><td>Macports不会卸载安装port时所安装的依赖，此选项可以卸载那些被卸载软件的依赖但并没有被其他软件所依赖的软件。</td></tr><tr><td>-f</td><td>(force)，强制卸载port，忽略软件间的依赖关系（尽量不要使用这个选项，除非你特别清楚你所做的操作）</td></tr><tr><td>–no-exec</td><td>卸载时不在触发事件监听，比如卸载时更新本地缓存将不会被执行。</td></tr></tbody></table><p><strong>13. port contents</strong><br>列出所有指定软件的所有安装的文件,此命令经常被用来寻找所安装软件的执行文件路径：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ port  contents &lt;portname&gt; | grep -E &apos;/s?bin/&apos;</span><br></pre></td></tr></table></figure><p></p><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>–size</td><td>列出文件时，同时给出文件大小</td></tr><tr><td>— units ‘UNIT’</td><td>配合—size使用，指定显示文件大小的单位</td></tr></tbody></table><p>‘UNIT’包含以下几种：<br>B<br>K, Ki,KiB<br>Mi,MiB<br>Gi,GiB<br>k, kB<br>M, MB<br>G, GB</p><p><strong>14. port installed</strong><br>列出已安装的软件及其变体，可以指定软件名，显示与所指定软件相关的安装。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ port installed</span><br></pre></td></tr></table></figure><p></p><p>-v 显示安装的平台以及CPU等信息</p><p><strong>15. port outdated</strong><br>列出所有版本已旧（已有新版本发布）的软件。</p><p><strong>16. port upgrade</strong><br>更新旧版本的已安装软件及其依赖，如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ port upgrade nginx</span><br><span class="line">更新nginx</span><br><span class="line"></span><br><span class="line">$ port upgrade outdated</span><br><span class="line">更新所有旧版本已安装软件及其依赖，</span><br></pre></td></tr></table></figure><p></p><p><strong>17. port dependents</strong><br>查询依赖已安装的指定软件的软件,比如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ port dependents php56</span><br><span class="line">查询电脑中有哪些软件依赖php56</span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.macports.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mac
      
    
    </summary>
    
    
      <category term="Mac" scheme="http://blog.zhanghuiliang.cn/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>CentOS虚拟机无法连接网络</title>
    <link href="http://blog.zhanghuiliang.cn/2016/12/16/CentOS%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BB%9C/"/>
    <id>http://blog.zhanghuiliang.cn/2016/12/16/CentOS虚拟机无法连接网络/</id>
    <published>2016-12-16T07:54:51.000Z</published>
    <updated>2017-09-08T02:34:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>cd /etc/sysconfig/network-scripts/</p><p>sudo vim ifcfg-eno16777736</p><p>更改ONBOOT=no 为 ONBOOT=yes</p><p>重启网络 service network restart</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;cd /etc/sysconfig/network-scripts/&lt;/p&gt;&lt;p&gt;sudo vim ifcfg-eno16777736&lt;/p&gt;&lt;p&gt;更改ONBOOT=no 为 ONBOOT=yes&lt;/p&gt;&lt;p&gt;重启网络 service network restart&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog.zhanghuiliang.cn/tags/Linux/"/>
    
  </entry>
  
</feed>
